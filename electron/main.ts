import { createRequestHandler, } from "@remix-run/express";
import express from 'express';
import { app, BrowserWindow } from 'electron';
import type { Server } from 'http';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import  electronLog from 'electron-log';


// Configure electron-log
// By default, logs are stored in:
// on Linux: ~/.config/{app name}/logs/
// on macOS: ~/Library/Logs/{app name}/
// on Windows: %USERPROFILE%\AppData\Roaming\{app name}\logs\

electronLog.transports.file.level = 'info';
electronLog.transports.file.format = '[{y}-{m}-{d} {h}:{i}:{s}] [{level}] {text}';
electronLog.transports.file.maxSize = 5 * 1024 * 1024; // 5MB
// electronLog.transports.file.rotation = 5; // Keep 5 files

// Replace console.log with electron-log
Object.assign(console, electronLog.functions);


// ESM __dirname equivalent
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

let mainWindow: BrowserWindow | null = null;
let server: Server | null = null;
const PORT = process.env.PORT || 3000;

const originalConsoleLog = console.log
console.log = (...args) => {
    originalConsoleLog(...args)
    mainWindow?.webContents.send('log', args)
}


// Initialize Express app with middleware
const expressApp = express();

// Serve static files from the client build directory
const clientBuildPath = join(__dirname, '../build/client');
expressApp.use(express.static(clientBuildPath, { immutable: true, maxAge: '1y' }));

// Handle all other routes with Remix
async function initializeServer() {
    try {
        // Import the Remix build using dynamic import()
        // const buildPath = join('.', '../build/server/index.js');
        const buildPath = '../build/server/index.js';
        // console.log('Loading Remix build from:', buildPath);
        // @ts-ignore because the server build file is generated by `remix vite:build`
        const remixBuild = await import(buildPath);

        // Add the Remix handler after build is loaded
        expressApp.all(
            "*",
            createRequestHandler({
                build: remixBuild as unknown as any,
                mode: process.env.NODE_ENV
            })
        );

        return new Promise<Server>((resolve, reject) => {
            const newServer = expressApp.listen(PORT, () => {
                console.log(`Express server running on port ${PORT}`);
                resolve(newServer);
            });

            newServer.on('error', (error) => {
                reject(error);
            });
        });
    } catch (error) {
        console.error('Failed to initialize server:', error);
        throw error;
    }
}

async function createWindow() {
    try {
        // Start the server if it's not already running
        if (!server) {
            server = await initializeServer();
        }

        mainWindow = new BrowserWindow({
            width: 1200,
            height: 800,
            webPreferences: {
                nodeIntegration: true,
                contextIsolation: false
            }
        });
        

        // Load the Remix app through Express
        await mainWindow.loadURL(`http://localhost:${PORT}`);

        // Open DevTools in development
        if (process.env.NODE_ENV === 'development') {
            mainWindow.webContents.openDevTools();
        }

        mainWindow.on('closed', () => {
            mainWindow = null;
        });
    } catch (error) {
        console.error('Failed to create window:', error);
        app.quit();
    }
}
app.commandLine.appendSwitch('remote-debugging-port', '8315')
// App event handlers
app.whenReady().then(createWindow).catch(error => {
    console.error('Failed to initialize app:', error);
    app.quit();
});

app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});

// Cleanup Express server on app quit
app.on('before-quit', () => {
    if (server) {
        server.close();
        server = null;
    }
});

// Handle any unhandled errors
process.on('uncaughtException', (error) => {
    console.error('Uncaught exception:', error);
    if (server) {
        server.close();
    }
    app.quit();
});

process.on('unhandledRejection', (error) => {
    console.error('Unhandled rejection:', error);
    if (server) {
        server.close();
    }
    app.quit();
});